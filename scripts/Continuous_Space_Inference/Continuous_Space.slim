initialize() {
	initializeSLiMModelType("nonWF"); // A NWF model is simulated under the following conditions
	initializeSLiMOptions(dimensionality="xy"); //A 2D space modeled
	defineConstant("S_COEFF", 0.01); // Selection coefficient 
	if (!exists("MIG")) 
		defineConstant("MIG",0.05); // Under this model, MIG is just a value. It should be between 0 and 1
	defineConstant("SIGMA", MIG); // Dispersion (SD) <- this should be as (D) in difussion models
	defineConstant("MU", 1.2e-8);    // A real mutation rate
	initializeMutationRate(MU);
	// Mutations:
	// m1: Neutral
	// m2: Under natural selection (S_COEFF will be applied manually in early())
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 0.5, "f", 0.01);
	initializeGenomicElementType("g1", c(m1, m2), c(0.99, 0.01)); //This should be the proportion of m1 and m2 that will appear in our sims
	//Structure of our Chrs
	rec_ends = NULL;
	rec_rates = NULL;
	// We build 20 fragments of 1000bp with free recombinations each one of them
	for (index in 1:10) {
		start = (index - 1)*1000;
		end = start + 999;
		initializeGenomicElement(g1, start, end);
		
		rec_ends = c(rec_ends, end);
		rec_rates = c(rec_rates, 1e-8); // Recombination rate INSIDE genes
		
		rec_ends = c(rec_ends, end + 1);
		rec_rates = c(rec_rates, 0.5);  // RRecombination rate BETWEEN genes
	}
	
	initializeRecombinationRate(rec_rates, rec_ends);
	
	// MODEL'S CONSTANTS
	defineConstant("K", 2000);      // Capacidad de carga total aprox
	defineConstant("N", 2000);      // Tamaño inicial
	defineConstant("GRID_SIZE", 10); // Para la discretización virtual (10x10)
	defineConstant("OUTPUT_PATH", "/mnt/data/dortega/hlopezh/Inf_MigSelection/data/results_Continuous/outputs_slim/");
	if (!exists("id_replica"))
        defineConstant("id_replica", 1);
	
	// Parámetros de movimiento
	defineConstant("SD", SIGMA); // Sigma de Dispersión (Natal)
	defineConstant("SV", 0.01);  // Movimiento adulto
	defineConstant("SM", 0.01);  // Búsqueda de pareja
	//TODO: Experimentar con 0.01 y ver cuáles son los parámetros que infiere
	//TODO: Experimentar con 0.001 y 0.0001
	//INPROGRESS: Experimentar con 500 y 1000

	// Interacciones Espaciales
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SD*3); // Competencia
	i1.setInteractionFunction("n", 1.0, SD*3);
	
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SM*3); // Apareamiento
	i2.setInteractionFunction("n", 1.0, SM*3);
}

1 early() {
	sim.addSubpop("p1", N);
	p1.setSpatialBounds(c(0.0, 0.0, 1.0, 1.0));
	p1.individuals.setSpatialPosition(p1.pointUniform(N));
	
	// --- PREPARACIÓN DE ARCHIVOS DE SALIDA ---
	writeFile(OUTPUT_PATH + "C_FULL_neutros_m1_" + id_replica + ".csv","Generation,MutationID,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
	
	writeFile(OUTPUT_PATH + "C_FULL_seleccion_m2_" + id_replica + ".csv","Generation,MutationID,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
	
    //writeFile(OUTPUT_PATH + "C_aDNA_scattered_neutros_m1_" + id_replica + ".csv","Generation,MutationID,MutType,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);

    //writeFile(OUTPUT_PATH + "C_aDNA_scattered_seleccion_m2_" + id_replica + ".csv","Generation,MutationID,MutType,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
}

2: first() {
	i2.evaluate(p1);
}

early() {
	// 1. DENSIDAD Y COMPETENCIA
	i1.evaluate(p1);
	inds = p1.individuals;
	competition = i1.totalOfNeighborStrengths(inds);
	
	// Regulación de densidad (Fitness Scaling)
	// Ajustamos para que la población local no explote
	inds.fitnessScaling = 1.0 / (1.0 + (competition / (K / (GRID_SIZE*GRID_SIZE))));
	
	// 2. MOVIMIENTO ADULTO
	pos = p1.pointDeviated(inds.size(), inds.spatialPosition, "reflecting", 1000, "n", SV);
	inds.setSpatialPosition(pos);
	
	// 3. SELECCIÓN NATURAL (Vía Fecundidad)
	
	// Contamos copias de m2 (seleccionada)
	mut_count = inds.countOfMutationsOfType(m2);
	
	// Efecto aditivo: 1 + S * n_copias
	selection_multiplier = 1.0 + S_COEFF * mut_count;
	
	// Tasa base f0=4, ajustada por selección
	f_w = 4.0 * selection_multiplier;
	inds.tag = rpois(inds.size(), lambda = f_w);
}

// REPRODUCCIÓN (La dispersión genética ocurre aquí)
reproduction() {
	mate = i2.nearestNeighbors(individual, 1);
	if (mate.size()) {
		for (i in seqLen(individual.tag)) {
			offspring = subpop.addCrossed(individual, mate);
			// Dispersión natal (Motor de la difusión D)
			pos = individual.spatialPosition + rnorm(2, 0, SD);
			offspring.setSpatialPosition(p1.pointReflected(pos));
		}
	}
}

// SALIDA DE DATOS (Mapeo Continuo -> Discreto Virtual)
600:1000 late() {
	
	if (sim.cycle % 50 == 0) catn("Tick: " + sim.cycle + " Pob: " + p1.individualCount);
	
	grid_bins = Dictionary();
	inds = p1.individuals;
	
	// Calcular coordenada de celda (0-9)
	xs = asInteger(floor(inds.x * GRID_SIZE));
	ys = asInteger(floor(inds.y * GRID_SIZE));
	
	// Corrección de bordes
	xs = ifelse(xs >= GRID_SIZE, GRID_SIZE - 1, xs);
	ys = ifelse(ys >= GRID_SIZE, GRID_SIZE - 1, ys);
	
	// ID único de celda
	bin_ids = xs * GRID_SIZE + ys;
	
	// Llenar diccionario
	for (i in 0:(size(inds)-1)) {
		id = bin_ids[i];
		// Eidos convierte 'id' a string automáticamente al usarlo como llave
		existing_content = grid_bins.getValue(id);
		
		if (isNULL(existing_content))
			grid_bins.setValue(id, inds[i]);
		else
			grid_bins.setValue(id, c(existing_content, inds[i]));
	}
	
	available_bins = grid_bins.allKeys;
	
	// CORRECCIÓN 1: Inicializar como vectores vacíos de verdad
	lines_m1 = character(0); // <--- !!! IMPORTANTE
	lines_m2 = character(0); // <--- !!! IMPORTANTE
	
	for (bin_id in available_bins) {
		inds_in_bin = grid_bins.getValue(bin_id);
		
		// CORRECCIÓN 2: Convertir la llave (que es String) a Entero para hacer matemáticas
		bin_val = asInteger(bin_id); // <--- !!! IMPORTANTE
		
		x_grid = asInteger(bin_val / GRID_SIZE) + 1; // Usamos bin_val, no bin_id
		y_grid = (bin_val % GRID_SIZE) + 1;          // Usamos bin_val, no bin_id
		
		all_genomes = inds_in_bin.haplosomes; 
		chr_tot = size(all_genomes);
		all_muts = unique(all_genomes.mutations);
		
		for (m in all_muts) {
			count = sum(all_genomes.mutations == m);
			freq = count / asFloat(chr_tot);
			
			// m2 (Selección) - Guardamos todo
			if (m.mutationType == m2) {
				line = paste(c(sim.cycle, m.id, x_grid, y_grid, freq, count, chr_tot), sep=",");
				lines_m2 = c(lines_m2, line);
			}
			// m1 (Neutro) - Filtro > 1% global (opcional, pero tu comentario decía filtro global)
            // Aquí lo dejé tal cual lo tenías, guardando todo.
			else if (m.mutationType == m1) {
				line = paste(c(sim.cycle, m.id, x_grid, y_grid, freq, count, chr_tot), sep=",");
				lines_m1 = c(lines_m1, line);
			}
		}
	}
	
	// Ahora length sí será 0 si no hay datos, y >0 si hay datos correctos
	if (length(lines_m1) > 0)
		writeFile(OUTPUT_PATH + "C_FULL_neutros_m1_" + id_replica + ".csv", paste(lines_m1, sep="\n"), append=T);
		
	if (length(lines_m2) > 0)
		writeFile(OUTPUT_PATH + "C_FULL_seleccion_m2_" + id_replica + ".csv", paste(lines_m2, sep="\n"), append=T);

	//if (size(available_bins) > 0) {
		// Número de sitios arqueológicos descubiertos (1 a 10)
	//	num_sites = rdunif(1, 1, 10);
	//	sites_to_sample_count = min(num_sites, size(available_bins));
		
	//	if (sites_to_sample_count > 0) {
	//		sampled_bin_ids = sample(available_bins, sites_to_sample_count);
			//TODO: Adaptar el codigo de esta parte para que registre también
			//el mismo filtro que hay de 0.0001 frq global que hay en
			//el script discreto
	//		lines_aDNA_m1 = "";
    //        lines_aDNA_m2 = "";
			
	//		for (bin_id in sampled_bin_ids) {
	//			inds_in_bin = grid_bins.getValue(bin_id);
				
				// Coordenadas discretas (1 a 10)
	//			x_grid = asInteger(bin_id / GRID_SIZE) + 1;
	//			y_grid = (bin_id % GRID_SIZE) + 1;
				
				// Número de individuos en el yacimiento (1 a 100)
	//			num_inds_to_sample = rdunif(1, 1, 100);
	//			num_inds_real = min(num_inds_to_sample, size(inds_in_bin));
				
	//			if (num_inds_real > 0) {
	//				sampled_inds = sample(inds_in_bin, num_inds_real);
	//				sampled_genomes = sampled_inds.haplosomes;
	//				current_chr_tot = size(sampled_genomes);
	//				muts_in_sample = unique(sampled_genomes.mutations);
					
	//				for (m in muts_in_sample) {
	//					mut_type_str = "NA";
	//					if (m.mutationType == m1) mut_type_str = "m1";
	//					else if (m.mutationType == m2) mut_type_str = "m2";
						
	//					if (mut_type_str != "NA") {
	//						count = sum(sampled_genomes.mutations == m);
	//						freq = count / asFloat(current_chr_tot);
	//						
	//						line = paste(c(sim.cycle, m.id, mut_type_str, x_grid, y_grid, freq, count, current_chr_tot), sep=",");
	//						if (m.mutationType == m1)
      //                          lines_aDNA_m1 = c(lines_aDNA_m1, line);
     //                       else if (m.mutationType == m2)
     //                           lines_aDNA_m2 = c(lines_aDNA_m2, line);
	//					}
	//				}
	//			}
	//		}
	//		if (length(lines_aDNA_m1) > 0)
    //            writeFile(OUTPUT_PATH + "C_aDNA_scattered_neutros_m1_" + id_replica + ".csv", paste(lines_aDNA_m1, sep="\n"), append=T);
            
    //        if (length(lines_aDNA_m2) > 0)
    //            writeFile(OUTPUT_PATH + "C_aDNA_scattered_seleccion_m2_" + id_replica + ".csv", paste(lines_aDNA_m2, sep="\n"), append=T);
	//	}
	//}
	
}