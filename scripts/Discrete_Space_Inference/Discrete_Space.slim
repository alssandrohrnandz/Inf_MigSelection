initialize() {
	//initializeSex("A"); 
	defineConstant("SubpopSize", 1000);
	if (!exists("MIG")) //TODO: Valores a experimentar de migración, 0.1 0.01, 0.001, 0.0001, 0.00001
		defineConstant("MIG",0.05);
	defineConstant("Migration", MIG);
	defineConstant("pop", 10);
	if (!exists("id_replica"))
		defineConstant("id_replica", 1);
	defineConstant("matrix_size", pop*pop);
	defineConstant("OUTPUT_PATH", "/mnt/data/dortega/hlopezh/Inf_MigSelection/data/results_Discrete/outputs_slim/");
	defineConstant("MU", 1.2e-8);
	initializeMutationRate(MU);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 0.5, "f", 0.01);
	
	initializeGenomicElementType("g1", c(m1,m2), c(0.99, 0.01));
	
	rec_ends = NULL;
	rec_rates = NULL;
	for (index in 1:20) {
		start = (index - 1)*1000;
		end = start + 999;
		initializeGenomicElement(g1, start, end);
		rec_ends = c(rec_ends, end);
		rec_rates = c(rec_rates, 1e-8);
		rec_ends = c(rec_ends, end + 1);
		rec_rates = c(rec_rates, 0.5);
	}
	initializeRecombinationRate(rec_rates, rec_ends);
}

1 early() {
	// Configuración de la grilla (Stepping Stone 10x10)
	metapopSide = pop;
	metapopSize = pop*pop;
	for (i in 1:metapopSize)
		sim.addSubpop(i, SubpopSize);
	
	subpops = sim.subpopulations;
	for (x in 1:metapopSide)
		for (y in 1:metapopSide) {
			destID = (x - 1) + (y - 1) * metapopSide + 1;
			ds = subpops[destID - 1];
			// Migración
			if (x > 1) ds.setMigrationRates(destID - 1, Migration);
			if (x < metapopSide) ds.setMigrationRates(destID + 1, Migration);
			if (y > 1) ds.setMigrationRates(destID - metapopSide, Migration);
			if (y < metapopSide) ds.setMigrationRates(destID + metapopSide, Migration);
			
			// GUI
			xd = ((x - 1) / (metapopSide - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (metapopSide - 1)) * 0.9 + 0.05;
			ds.configureDisplay(c(xd, yd), 0.4);
		}
	
	// 1. Verdad Terreno (Neutro)
	writeFile(OUTPUT_PATH + "D_FULL_neutros_m1_" + id_replica + ".csv",
		"Generation,MutationID,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
	
	// 2. Verdad Terreno (Selección)
	writeFile(OUTPUT_PATH + "D_FULL_seleccion_m2_" + id_replica + ".csv",
		"Generation,MutationID,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
	// aDNA Neutros
	writeFile(OUTPUT_PATH + "D_aDNA_scattered_neutros_m1_" + id_replica + ".csv",
		"Generation,MutationID,MutType,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
	
	// aDNA Selección
	writeFile(OUTPUT_PATH + "D_aDNA_scattered_seleccion_m2_" + id_replica + ".csv",
		"Generation,MutationID,MutType,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
}

// Muestreo de la generación 600 a la 1000
600:1000 late() {
	
	if (sim.cycle % 50 == 0) catn("Tick: " + sim.cycle);
	n = asInteger(sqrt(matrix_size));
	
	// ==========================================================
	// 1. GENERACIÓN DE DATOS DISPERSOS (aDNA SIMULADO HETEROGÉNEO)
	// ==========================================================
	
	// Seleccionamos al azar 2 ubicaciones donde "encontramos fósiles" en esta generación
	sampled_pops = sample(sim.subpopulations, rdunif(1, 1, 10));
	
	lines_aDNA_m1 = ""; // Acumulador para m1
	lines_aDNA_m2 = ""; // Acumulador para m2
	
	for (subpop in sampled_pops) {
		//aDNA conditions
		num_inds_to_sample = rdunif(1, 1, 100);
		
		//Sample of individuals
		sampled_inds = subpop.sampleIndividuals(num_inds_to_sample);
		if (size(sampled_inds) > 0) {
			sampled_genomes = sampled_inds.haplosomes;
			current_chr_tot = size(sampled_genomes);
			muts_in_sample = unique(sampled_genomes.mutations);
			// Coordenadas (cap 17.3)
			index = subpop.id - 1;
			x_pos = (index % n) + 1;
			y_pos = asInteger(index / n) + 1;
			//Vectorizacion para no leer todas las mutaciones
			//Esta parte es importante porque anteriormente usaba un (sim.mutationFrequencies(NULL,m)>0.0001){}
			//lo cuál me retraso mucho el cálculo de las frecuencias, este método es mejor.
			//Actua como filtro de calidad
			//TODO: Revisar con Diego en un futuro pero no es prioritaria esta seccion
			global_freqs = sim.mutationFrequencies(NULL, muts_in_sample); //Calcula todas las frecuencias
			pass_filter = (global_freqs > 0.0001); // Aquí solo escogemos las mutaciones
			muts_to_process = muts_in_sample[pass_filter];

			for (m in muts_to_process) {
				count_in_sample = sum(sampled_genomes.mutations == m); // NUEVO total
				freq_in_sample = count_in_sample / asFloat(current_chr_tot); //NUEVO freq in sample
				mut_type_str = "NA";
                if (m.mutationType == m1) {
                    mut_type_str = "m1";
                    line = paste(c(sim.cycle, m.id, mut_type_str, x_pos, y_pos, freq_in_sample, count_in_sample, current_chr_tot), sep=",");
                    lines_aDNA_m1 = c(lines_aDNA_m1, line);
                } 
                else if (m.mutationType == m2) {
                    mut_type_str = "m2";
                    line = paste(c(sim.cycle, m.id, mut_type_str, x_pos, y_pos, freq_in_sample, count_in_sample, current_chr_tot), sep=",");
                    lines_aDNA_m2 = c(lines_aDNA_m2, line);
				}
				
			}
		}
	
	}
	
	if (length(lines_aDNA_m1) > 0)
		writeFile(OUTPUT_PATH + "D_aDNA_scattered_neutros_m1_" + id_replica + ".csv",
		paste(lines_aDNA_m1, sep="\n"), append=T);
	
	if (length(lines_aDNA_m2) > 0)
		writeFile(OUTPUT_PATH + "D_aDNA_scattered_seleccion_m2_" + id_replica + ".csv",
		paste(lines_aDNA_m2, sep="\n"), append=T);
	
	// --- M2 FULL ---
	muts_m2 = sim.mutationsOfType(m2);
	if (size(muts_m2) > 0) {
		lines_m2 = "";
		for (m in muts_m2) {
			for (subpop in sim.subpopulations) {
				freq = sim.mutationFrequencies(subpop, m);
				// Guardamos todo, incluso ceros para m2
				chr_tot = 2 * size(subpop.individuals);
				allele_count = asInteger(round(freq * chr_tot));
				index = subpop.id - 1;
				x_pos = (index % n) + 1;
				y_pos = asInteger(index / n) + 1;
				line = paste(c(sim.cycle, m.id, x_pos, y_pos, freq, allele_count, chr_tot), sep=",");
				lines_m2 = c(lines_m2, line);
			}
			
		}
		if (length(lines_m2) > 0)
			writeFile(OUTPUT_PATH + "D_FULL_seleccion_m2_" + id_replica + ".csv",
			paste(lines_m2, sep="\n"), append=T);
	}
	
	// --- M1 FULL ---
	muts_m1 = sim.mutationsOfType(m1);
	if (size(muts_m1) > 0) {
		lines_m1 = "";
		for (m in muts_m1) {
			for (subpop in sim.subpopulations) {
				freq = sim.mutationFrequencies(subpop, m);
				if (freq > 0) {
					chr_tot = 2 * size(subpop.individuals);
					allele_count = asInteger(round(freq * chr_tot));
					index = subpop.id - 1;
					x_pos = (index % n) + 1;
					y_pos = asInteger(index / n) + 1;
					line = paste(c(sim.cycle, m.id, x_pos, y_pos, freq, allele_count, chr_tot), sep=",");
					lines_m1 = c(lines_m1, line);
				}
			}
		}
		if (length(lines_m1) > 0)
			writeFile(OUTPUT_PATH + "D_FULL_neutros_m1_" + id_replica + ".csv",
			paste(lines_m1, sep="\n"), append=T);
	}
}