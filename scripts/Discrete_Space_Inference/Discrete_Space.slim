initialize() {
	//initializeSex("A"); 
	defineConstant("SubpopSize", 1000);
	if (!exists("MIG")) //TODO: Valores a experimentar de migración, 0.1 0.01, 0.001, 0.0001, 0.00001
		defineConstant("MIG",0.05);
	defineConstant("Migration", MIG);
	defineConstant("pop", 10);
	if (!exists("id_replica"))
		defineConstant("id_replica", 1);
	defineConstant("matrix_size", pop*pop);
	defineConstant("OUTPUT_PATH", "/mnt/data/dortega/hlopezh/Inf_MigSelection/data/results_Discrete/outputs_slim/");
	defineConstant("MU", 1.2e-8);
	initializeMutationRate(MU);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 0.5, "f", 0.01);
	
	initializeGenomicElementType("g1", c(m1,m2), c(0.99, 0.01));
	
	rec_ends = NULL;
	rec_rates = NULL;
	for (index in 1:20) {
		start = (index - 1)*1000;
		end = start + 999;
		initializeGenomicElement(g1, start, end);
		rec_ends = c(rec_ends, end);
		rec_rates = c(rec_rates, 1e-8);
		rec_ends = c(rec_ends, end + 1);
		rec_rates = c(rec_rates, 0.5);
	}
	initializeRecombinationRate(rec_rates, rec_ends);
}

1 early() {
	// Configuración de la grilla (Stepping Stone 10x10)
	metapopSide = pop;
	metapopSize = pop*pop;
	for (i in 1:metapopSize)
		sim.addSubpop(i, SubpopSize);
	
	subpops = sim.subpopulations;
	for (x in 1:metapopSide)
		for (y in 1:metapopSide) {
			destID = (x - 1) + (y - 1) * metapopSide + 1;
			ds = subpops[destID - 1];
			// Migración
			if (x > 1) ds.setMigrationRates(destID - 1, Migration);
			if (x < metapopSide) ds.setMigrationRates(destID + 1, Migration);
			if (y > 1) ds.setMigrationRates(destID - metapopSide, Migration);
			if (y < metapopSide) ds.setMigrationRates(destID + metapopSide, Migration);
			
			// GUI
			xd = ((x - 1) / (metapopSide - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (metapopSide - 1)) * 0.9 + 0.05;
			ds.configureDisplay(c(xd, yd), 0.4);
		}
	
	// 1. Verdad Terreno (Neutro)
	writeFile(OUTPUT_PATH + "D_FULL_neutros_m1_" + id_replica + ".csv",
		"Generation,MutationID,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
	
	// 2. Verdad Terreno (Selección)
	writeFile(OUTPUT_PATH + "D_FULL_seleccion_m2_" + id_replica + ".csv",
		"Generation,MutationID,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
	// aDNA Neutros
	writeFile(OUTPUT_PATH + "D_aDNA_scattered_neutros_m1_" + id_replica + ".csv",
		"Generation,MutationID,MutType,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
	
	// aDNA Selección
	writeFile(OUTPUT_PATH + "D_aDNA_scattered_seleccion_m2_" + id_replica + ".csv",
		"Generation,MutationID,MutType,X,Y,Frequency,AlleleCount,Chr_Tot", append=F);
}

// Muestreo de la generación 600 a la 1000
600:1000 late() {
	
	if (sim.cycle % 50 == 0) catn("Tick: " + sim.cycle);
	n = asInteger(sqrt(matrix_size));
	
	// ==========================================================
	// 1. GENERACIÓN DE DATOS DISPERSOS (aDNA SIMULADO HETEROGÉNEO)
	// ==========================================================
	
	// Seleccionamos al azar 2 ubicaciones donde "encontramos fósiles" en esta generación
	sampled_pops = sample(sim.subpopulations, rdunif(1, 1, 10));
	
	lines_aDNA_m1 = ""; // Acumulador para m1
	lines_aDNA_m2 = ""; // Acumulador para m2
	
	for (subpop in sampled_pops) {
		//aDNA conditions
		num_inds_to_sample = rdunif(1, 1, 100);
		
		//Sample of individuals
		sampled_inds = subpop.sampleIndividuals(num_inds_to_sample);
		if (size(sampled_inds) > 0) {
			sampled_genomes = sampled_inds.haplosomes;
			current_chr_tot = size(sampled_genomes);
			muts_in_sample = unique(sampled_genomes.mutations);
			// Coordenadas (cap 17.3)
			index = subpop.id - 1;
			x_pos = (index % n) + 1;
			y_pos = asInteger(index / n) + 1;
			//Vectorizacion para no leer todas las mutaciones
			//Esta parte es importante porque anteriormente usaba un (sim.mutationFrequencies(NULL,m)>0.0001){}
			//lo cuál me retraso mucho el cálculo de las frecuencias, este método es mejor.
			//Actua como filtro de calidad
			//TODO: Revisar con Diego en un futuro pero no es prioritaria esta seccion
			global_freqs = sim.mutationFrequencies(NULL, muts_in_sample); //Calcula todas las frecuencias
			pass_filter = (global_freqs > 0.0001); // Aquí solo escogemos las mutaciones
			muts_to_process = muts_in_sample[pass_filter];

			for (m in muts_to_process) {
				count_in_sample = sum(sampled_genomes.mutations == m); // NUEVO total
				freq_in_sample = count_in_sample / asFloat(current_chr_tot); //NUEVO freq in sample
				mut_type_str = "NA";
                if (m.mutationType == m1) {
                    mut_type_str = "m1";
                    line = paste(c(sim.cycle, m.id, mut_type_str, x_pos, y_pos, freq_in_sample, count_in_sample, current_chr_tot), sep=",");
                    lines_aDNA_m1 = c(lines_aDNA_m1, line);
                } 
                else if (m.mutationType == m2) {
                    mut_type_str = "m2";
                    line = paste(c(sim.cycle, m.id, mut_type_str, x_pos, y_pos, freq_in_sample, count_in_sample, current_chr_tot), sep=",");
                    lines_aDNA_m2 = c(lines_aDNA_m2, line);
				}
				
			}
		}
	
	}
	
	if (length(lines_aDNA_m1) > 0)
		writeFile(OUTPUT_PATH + "D_aDNA_scattered_neutros_m1_" + id_replica + ".csv",
		paste(lines_aDNA_m1, sep="\n"), append=T);
	
	if (length(lines_aDNA_m2) > 0)
		writeFile(OUTPUT_PATH + "D_aDNA_scattered_seleccion_m2_" + id_replica + ".csv",
		paste(lines_aDNA_m2, sep="\n"), append=T);
	
	// --- M2 FULL (CORREGIDO PARA FORMATO VERTICAL) ---
    muts_m2 = sim.mutationsOfType(m2);
    if (size(muts_m2) > 0) {
        m_ids = muts_m2.id;
        
        // Iteramos Subpoblación por Subpoblación
        for (subpop in sim.subpopulations) {
            
            // 1. Datos de la Subpoblación
            idx = subpop.id - 1; 
            x_p = (idx % n) + 1;
            y_p = asInteger(idx / n) + 1;
            pop_size_2n = subpop.individualCount * 2;
            
            // 2. CÁLCULO VECTORIZADO (Rápido)
            // Obtenemos un vector con TODAS las frecuencias de esta subpoblación
            freqs = sim.mutationFrequencies(subpop, muts_m2);
            counts = asInteger(round(freqs * pop_size_2n));
            
            // 3. CONSTRUCCIÓN DEL CSV (Fila por Fila)
            // Iteramos sobre los índices del vector 'freqs' para sacar los datos uno por uno
            
            subpop_lines = NULL; // Buffer temporal solo para esta subpoblación
            
            for (i in 0:(size(freqs)-1)) {
                // AQUÍ ESTÁ LA CLAVE: Usamos [i] para sacar UN solo valor a la vez
                line = paste(c(sim.cycle, m_ids[i], x_p, y_p, freqs[i], counts[i], pop_size_2n), sep=",");
                subpop_lines = c(subpop_lines, line);
            }
            
            // 4. Escritura inmediata (ahorra memoria RAM)
            if (size(subpop_lines) > 0) {
                writeFile(OUTPUT_PATH + "D_FULL_seleccion_m2_" + id_replica + ".csv",paste(subpop_lines, sep="\n"), append=T);
            }
        }
    }

    // --- M1 FULL (CORREGIDO PARA FORMATO VERTICAL) ---
    muts_m1 = sim.mutationsOfType(m1); //TODO: REVISAR ESTA SECCION DE NUEVO
    if (size(muts_m1) > 0) {
        m_ids = muts_m1.id;
        
        for (subpop in sim.subpopulations) {
            
            idx = subpop.id - 1;
            x_p = (idx % n) + 1;
            y_p = asInteger(idx / n) + 1;
            pop_size_2n = subpop.individualCount * 2;
            
            // Vectorizado
            freqs = sim.mutationFrequencies(subpop, muts_m1);
            counts = asInteger(round(freqs * pop_size_2n));
            
            subpop_lines = NULL;
            
            // Bucle para formatear texto línea por línea
            for (i in 0:(size(freqs)-1)) {
                // OPCIONAL: Filtro para no guardar millones de ceros en m1 (ahorra espacio en disco)
                // if (freqs[i] > 0) { 
                    line = paste(c(sim.cycle, m_ids[i], x_p, y_p, freqs[i], counts[i], pop_size_2n), sep=",");
                    subpop_lines = c(subpop_lines, line);
                // }
            }
            
            if (size(subpop_lines) > 0) {
                writeFile(OUTPUT_PATH + "D_FULL_neutros_m1_" + id_replica + ".csv",paste(subpop_lines, sep="\n"), append=T);
            }
        }
    }s_m1 = sim.mutationsOfType(m1);
    if (size(muts_m1) > 0) {
        m_ids = muts_m1.id;
        
        for (subpop in sim.subpopulations) {
            idx = subpop.id - 1;
            x_p = (idx % n) + 1;
            y_p = asInteger(idx / n) + 1;
            
            // Frecuencias de miles de m1 en un solo paso
            freqs = sim.mutationFrequencies(subpop, muts_m1);
            
            pop_size_2n = subpop.individualCount * 2;
            counts = asInteger(round(freqs * pop_size_2n));
            
            // Filtrado opcional: Si quieres ahorrar espacio y no guardar ceros en m1
            // mask = (freqs > 0);
            // if (any(mask)) {
            //    lines = paste(..., freqs[mask], ...);
            //    writeFile(...);
            // }
            // Si quieres guardar TODO (incluso ceros), usa esto tal cual:
            
            lines = paste(sim.cycle, m_ids[i], x_p, y_p, freqs[i], counts[i], pop_size_2n, sep=",");
            
            writeFile(OUTPUT_PATH + "D_FULL_neutros_m1_" + id_replica + ".csv",paste(lines, sep="\n"), append=T);
        }
    }	
	
}